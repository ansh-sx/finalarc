from __future__ import annotations
from typing import List, Optional
from flask import Flask, request, jsonify
from webscout.LLM import LLM
from webscout import WEBS
import warnings

app = Flask(__name__)

system_message: str = (
    "As an AI assistant, I have been designed with advanced capabilities, including real-time access to online resources. This enables me to enrich our conversations and provide you with informed and accurate responses, drawing from a vast array of information. With each interaction, my goal is to create a seamless and meaningful connection, offering insights and sharing relevant content."
    "My directives emphasize the importance of respect, impartiality, and intellectual integrity. I am here to provide unbiased responses, ensuring an ethical and respectful exchange. I will respect your privacy and refrain from sharing any personal information that may be obtained during our conversations or through web searches, only utilizing web search functionality when necessary to provide the most accurate and up-to-date information."
    "Together, let's explore a diverse range of topics, creating an enjoyable and informative experience, all while maintaining the highest standards of privacy and respect"
    
)

predefined_text = """

You are a ai search engine and a helpful ai agent you have to create a researched proffesional answer like this im creating ,,,  here are the examples

The response format : 

{
  {
    "main" : Main Heading of the query ..create it in a professional way
  }
  {
    "sourx": all the source urls provided to you even yt or any
  }
  {
    "title": title ..create it by your own
    "sources": web urls from which data is used in this one data only for the other title its other from which its fetched. dont write all here , only those which are used or contain data most related to it
    "keywords": [1-3 word title for each content]
    "Content": [content and number of these lines should be equal to keywords count that is each keyword contains a para or a line for say]
    "Emojis": [emojis different ones for each keyword]
    "Conclusion": conclusion of the whole thing..
  }
  {
    "title": title ..create it by your own
    "sources": all web urls from which data is used in this one data only for the other title its other from which its fetched
    "keywords": [1-3 word title for each content]
    "Content": [content and number of these lines should be equal to keywords count that is each keyword contains a para or a line for say]
    "Emojis": [emojis different ones for each keyword]
    "Conclusion": conclusion of the whole thing..
  }
  ...and goes on ..create minimum of 6 like these .. can be more but never be less
  {
    "rltdq" : [related questions list that can strike user mind] 
  }
}

ok so this was the format now a sample example for the query "amazon vs flipkart":

{
  {
    "main": "Amazon Vs Flipkart: \n The Ultimate Comparison"
  }
  {
    "title": "Amazon"
    "sources": [provide the sources list here]
    "keywords: ["Founder","Headquarter","Shipping","Payment Methods","Customer ratings","Trust Score"]
    "content": [
                 "Founder of amazon is Jeff Bezos,born and other etc details..."
                 "Headquaters of amazon are located in here...and more things about it"
                 ....all others like this
               ]
    "Emojis": [different emoji for each keyword]
    "Conclusion": conclusion for all that
  }
  same for flipkart now...then other things like which is better in which category ..in short write everything about the query so user doesnty needs to go some other place to search for that query
}


remember that im using it as an api in my flask app so always give response in json format and the keyword count should be equal to content lines should be equal to number of emojis .. so that each keyword gets a content line and a emoji ...ok
these titles should be a minimum of 4 and can be more create more if needed ...use your knowledge also to create the best response
and dont write anything except the json response ..

"""

# Ignore the specific UserWarning
warnings.filterwarnings("ignore", category=UserWarning, module="curl_cffio", lineno=205)

LLM = LLM(model="mistralai/Mixtral-8x22B-Instruct-v0.1", system_message=system_message)


def chat(
    user_input: str, webs: WEBS, max_results: int = 10
) -> Optional[str]:
    """
    Chat function to perform a web search based on the user input and generate a response using the LLM model.

    Parameters
    ----------
    user_input : str
        The user input to be used for the web search
    webs : WEBS
        The web search instance to be used to perform the search
    max_results : int, optional
        The maximum number of search results to include in the response, by default 10

    Returns
    -------
    Optional[str]
        The response generated by the LLM model, or None if there is no response
    """
    # Perform a web search based on the user input
    search_results: List[str] = []
    for r in webs.text(
        user_input, region="wt-wt", safesearch="off", timelimit="y", max_results=max_results
    ):
        search_results.append(str(r))  # Convert each result to a string

    # Define the messages to be sent, including the user input, search results, and system message
    messages = [
        {"role": "user", "content": predefined_text + user_input + "\n" + "websearch results are:" + "\n".join(search_results)},
    ]

    # Use the chat method to get the response
    response = LLM.chat(messages)

    return response


# if __name__ == "__main__":
#     # while True:
#         # Get the user input
#         user_input = input("User:  ")

#         # Perform a web search based on the user input
#         with WEBS() as webs:
#             response = chat(user_input, webs)

#         # Print the response
#         if response:
#             print("AI:", response)
#         else:
#             print("No response")

@app.route('/query', methods=['GET'])
def query():
    user_input = request.args.get('d')

    if not user_input:
        return jsonify({'error': 'No user_input provided'}), 400

    with WEBS() as webs:
        response = chat(user_input, webs)

    return jsonify({"d": response})

if __name__ == '__main__':
    app.run(debug=True)
